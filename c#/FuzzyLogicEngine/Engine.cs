// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

using System.Xml;
using System.Runtime.Serialization;

using FuzzyLogic;

namespace FuzzyLogic
{
	[DataContract]
	public sealed class Engine
	{
		//
		[DataMember(Name="Objects")]
		internal List < Object > internals;
		//
		[IgnoreDataMember]
		public ObjectList<InputVariable> Inputs {
			get { return new ObjectList<InputVariable> (this); }
		}
		[IgnoreDataMember]
		public ObjectList<OutputVariable> Outputs {
			get { return new ObjectList<OutputVariable> (this); }
		}
		[IgnoreDataMember]
		public ObjectList<RuleBlock> Blocks {
			get { return new ObjectList<RuleBlock> (this); }
		}
		//
		public void SerializeMe ( string filename ) {
			var seri = new DataContractSerializer(typeof(Object));
			using(XmlWriter xw = XmlWriter.Create(filename)) {
				foreach ( Object obj in internals )
					seri.WriteObject(xw, obj);
			}
		}
		public TObject Create < TObject > (params object[] arguments) where TObject : Object, new()
		{
			//Console.WriteLine ("Create object: " + typeof(TObject).Name);
			TObject result = new TObject ();
			result.Referee = this;
			for ( int i = 0 ; i < arguments.Length ; i += 2 ) {
				string propname = (string) arguments [i];
				object propvalue = arguments [i + 1];
				var property = result.GetType ().GetProperty (propname);
				//Console.WriteLine ("Set property {0} with type {1} to {2} with type {3}",
				//	propname, property.PropertyType, propvalue, propvalue.GetType ());
				if (property.PropertyType.IsGenericType && (property.PropertyType.GetGenericTypeDefinition () == typeof(List<>))) {
					if (propvalue.GetType () == property.PropertyType) {
						//sets the list itself
						property.SetValue (result, propvalue, null);
					} else if (propvalue.GetType () == property.PropertyType.GetGenericArguments () [0]) {
						// adds an element to the list
						var list = property.GetValue (result, null);
						if (list == null) {
							//Console.WriteLine ("List is null in property adding");
							list = Activator.CreateInstance (property.PropertyType);
							property.SetValue (result, list, null);
						}
						IList ilist = (IList)list;
						ilist.Add (propvalue);
					} else if (typeof(int) == property.PropertyType.GetGenericArguments () [0]) {
						// adds an element to the list
						var list = property.GetValue (result, null);
						if (list == null) {
							//Console.WriteLine ("List is null in property adding");
							list = Activator.CreateInstance (property.PropertyType);
							property.SetValue (result, list, null);
						}
						IList ilist = (IList)list;
						ilist.Add (((Object)propvalue).ID);
					} else {
					}
				} else if (property.PropertyType.IsGenericType && (property.PropertyType.GetGenericTypeDefinition () == typeof(IndirectObjectList<>))) {
					//Console.WriteLine ("adding to indirect object list: "+propname);
					IIndirectObjectList list = (IIndirectObjectList) property.GetValue (result, null);
					list.Add (((Object)propvalue));
				} else if (property.PropertyType == propvalue.GetType ()) {
					//Console.WriteLine ("set property: " + propname);
					property.SetValue (result, propvalue, null);
				} else {
					//Console.WriteLine ("TRY set property: " + propname);
					property.SetValue (result, propvalue, null);
				}
			}
			if (internals == null)
				internals = new List<Object> ();
			internals.Add (result);
			return result;
		}
	}
}

